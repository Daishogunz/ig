<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Solar System: Step 3 - Real Stars</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        
        #ui {
            position: absolute; top: 20px; left: 20px;
            color: #fff; font-family: 'Courier New', Courier, monospace;
            pointer-events: none; z-index: 10;
            text-shadow: 0 0 10px rgba(79, 208, 231, 0.5);
        }
        h1 { margin: 0; font-size: 1.2rem; color: #4FD0E7; letter-spacing: 2px; text-transform: uppercase; }
        p { font-size: 0.8rem; color: #aaa; margin-top: 5px; }
        
        button {
            pointer-events: auto;
            margin-top: 15px;
            background: rgba(0, 50, 80, 0.7);
            border: 1px solid #4FD0E7;
            color: #4FD0E7;
            padding: 8px 16px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            font-size: 0.75rem;
            transition: 0.3s;
            border-radius: 4px;
        }
        button:hover { background: #4FD0E7; color: #000; box-shadow: 0 0 15px rgba(79, 208, 231, 0.5); }

        .label {
            color: rgba(255, 255, 255, 0.9);
            font-family: 'Segoe UI', sans-serif;
            font-size: 11px;
            font-weight: 700;
            padding: 5px 10px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            pointer-events: auto;
            cursor: pointer;
            user-select: none;
            backdrop-filter: blur(2px);
            transition: opacity 0.5s ease, transform 0.2s;
        }
        .label:hover {
            background: rgba(79, 208, 231, 0.4);
            border-color: #4FD0E7;
            transform: scale(1.15);
            box-shadow: 0 0 10px #4FD0E7;
        }
        .label.active {
            background: #FF4400;
            color: #fff;
            border-color: #FF4400;
            box-shadow: 0 0 15px #FF4400;
        }
        .label.hidden { opacity: 0; pointer-events: none; }
    </style>
</head>
<body>

    <div id="ui">
        <h1>SOLAR // STEP 3: REAL_STAR_COLORS</h1>
        <p>Spectral Classes O, B, G, M Simulation</p>
        <button onclick="resetCamera()">Reset View</button>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'three/addons/renderers/CSS2DRenderer.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        const CONFIG = {
            particleSize: 2.2,
            orbitSpeed: 0.08,
            camFov: 45
        };

        const PLANETS = [
            { name: "Mercury", r: 3, dist: 35, particles: 3000, speed: 4.0 },
            { name: "Venus", r: 4.5, dist: 50, particles: 5000, speed: 3.0 },
            { name: "Earth", r: 5, dist: 75, particles: 10000, speed: 2.0, hasClouds: true },
            { name: "Mars", r: 3.5, dist: 100, particles: 6000, speed: 1.6 },
            { name: "Jupiter", r: 14, dist: 160, particles: 25000, speed: 0.8 },
            { name: "Saturn", r: 11, dist: 220, particles: 20000, speed: 0.5, hasRings: true },
            { name: "Uranus", r: 7, dist: 270, particles: 10000, speed: 0.3 },
            { name: "Neptune", r: 6.8, dist: 320, particles: 10000, speed: 0.2 }
        ];

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.000005); 

        const camera = new THREE.PerspectiveCamera(CONFIG.camFov, window.innerWidth/window.innerHeight, 1, 100000);
        camera.position.set(0, 180, 400);

        const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.0;
        document.body.appendChild(renderer.domElement);

        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.15;
        bloomPass.strength = 1.4; 
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        const labelRenderer = new CSS2DRenderer();
        labelRenderer.setSize(window.innerWidth, window.innerHeight);
        labelRenderer.domElement.style.position = 'absolute';
        labelRenderer.domElement.style.top = '0px';
        document.body.appendChild(labelRenderer.domElement);

        const controls = new OrbitControls(camera, labelRenderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxDistance = 60000;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.3;

        // --- TEXTURES ---
        function createGlowDot() {
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32,32,0, 32,32,32);
            grad.addColorStop(0, 'rgba(255,255,255,1)');
            grad.addColorStop(0.4, 'rgba(255,255,255,0.5)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,64,64);
            return new THREE.CanvasTexture(canvas);
        }

        function createCloudTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64,64,0, 64,64,64);
            grad.addColorStop(0, 'rgba(255,255,255,0.15)'); 
            grad.addColorStop(0.6, 'rgba(255,255,255,0.05)');
            grad.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0,0,128,128);
            return new THREE.CanvasTexture(canvas);
        }

        const particleMat = new THREE.PointsMaterial({
            size: CONFIG.particleSize,
            map: createGlowDot(),
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true,
            opacity: 0.9
        });

        // --- GALAXY GENERATOR WITH REAL STAR CLASSES ---
        let galaxyMesh, nebulaeMesh;
        function createGalaxyWithRealStars() {
            const parameters = {
                count: 80000, 
                radius: 35000, 
                branches: 2, 
                spin: 1.5, 
                randomness: 0.6, 
                randomnessPower: 3
            };

            // 1. DEFINE REAL STAR CLASSES
            const STAR_CLASSES = {
                O: new THREE.Color(0x9db4ff), // Blue Giant (Hot)
                B: new THREE.Color(0xa2c0ff), // Blue-White
                A: new THREE.Color(0xcae8ff), // White
                G: new THREE.Color(0xfff4e8), // Yellow (Sun-like)
                K: new THREE.Color(0xffddb4), // Orange
                M: new THREE.Color(0xffbb7b)  // Red Dwarf (Cool)
            };

            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(parameters.count * 3);
            const colors = new Float32Array(parameters.count * 3);
            
            // To support size variation, we use a size attribute (requires ShaderMaterial or patching)
            // For simplicity here, we will stick to uniform size but use brightness to simulate size
            
            const nebulaCount = 15000;
            const nebulaGeo = new THREE.BufferGeometry();
            const nebulaPos = new Float32Array(nebulaCount * 3);
            const nebulaCols = new Float32Array(nebulaCount * 3);

            for (let i = 0; i < parameters.count; i++) {
                const i3 = i * 3;
                
                // Radius Logic
                const rNorm = Math.pow(Math.random(), 1.5);
                const r = rNorm * parameters.radius;
                
                let spinAngle = r * parameters.spin * 0.0001;
                let branchAngle = (i % parameters.branches) * ((Math.PI * 2) / parameters.branches);

                // Bar Structure Logic
                if (r < 6000) {
                    spinAngle = spinAngle * (r / 6000); 
                    branchAngle += (Math.random()-0.5) * 0.2; 
                }

                const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * r;
                const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * r * 0.15;
                const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() < 0.5 ? 1 : -1) * parameters.randomness * r;

                const x = Math.cos(branchAngle + spinAngle) * r + randomX;
                const y = randomY;
                const z = Math.sin(branchAngle + spinAngle) * r + randomZ;

                positions[i3] = x;
                positions[i3 + 1] = y;
                positions[i3 + 2] = z;

                // 2. ASSIGN STAR COLOR BASED ON LOCATION
                let starColor = new THREE.Color();
                let brightness = 1.0;

                // Core = Older Red/Yellow Stars
                if (r < 8000) {
                    const roll = Math.random();
                    if(roll > 0.7) starColor.copy(STAR_CLASSES.G); // Yellow
                    else if(roll > 0.3) starColor.copy(STAR_CLASSES.K); // Orange
                    else starColor.copy(STAR_CLASSES.M); // Red
                    brightness = 1.2;
                } 
                // Arms = Younger Blue Stars
                else {
                    const roll = Math.random();
                    if(roll > 0.95) { starColor.copy(STAR_CLASSES.O); brightness = 2.0; } // Rare O-Type
                    else if(roll > 0.85) { starColor.copy(STAR_CLASSES.B); brightness = 1.5; }
                    else if(roll > 0.6) starColor.copy(STAR_CLASSES.A);
                    else starColor.copy(STAR_CLASSES.G); // Background stars
                }

                // Apply color and brightness boost for bloom
                starColor.multiplyScalar(brightness);
                colors[i3] = starColor.r; 
                colors[i3 + 1] = starColor.g; 
                colors[i3 + 2] = starColor.b;

                // Nebulae Logic (From Step 2)
                if(i < nebulaCount) {
                    nebulaPos[i3] = x + (Math.random()-0.5)*1500;
                    nebulaPos[i3+1] = y + (Math.random()-0.5)*800;
                    nebulaPos[i3+2] = z + (Math.random()-0.5)*1500;
                    const nColor = new THREE.Color();
                    if(Math.random() > 0.5) nColor.setHex(0x440055); 
                    else nColor.setHex(0x660022); 
                    nColor.multiplyScalar(2.5); 
                    nebulaCols[i3] = nColor.r; nebulaCols[i3+1] = nColor.g; nebulaCols[i3+2] = nColor.b;
                }
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

            // Create Material with Vertex Colors enabled
            const material = particleMat.clone();
            material.vertexColors = true; // CRITICAL for star colors
            material.size = 150;
            material.opacity = 0;
            material.depthWrite = false;

            galaxyMesh = new THREE.Points(geometry, material);
            galaxyMesh.rotation.x = 0.2;
            galaxyMesh.position.y = -500; 
            scene.add(galaxyMesh);

            // Nebulae
            nebulaGeo.setAttribute('position', new THREE.BufferAttribute(nebulaPos, 3));
            nebulaGeo.setAttribute('color', new THREE.BufferAttribute(nebulaCols, 3));
            const nebulaMat = new THREE.PointsMaterial({
                size: 600,
                map: createCloudTexture(),
                vertexColors: true,
                transparent: true,
                opacity: 0, 
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                sizeAttenuation: true
            });
            nebulaeMesh = new THREE.Points(nebulaGeo, nebulaMat);
            galaxyMesh.add(nebulaeMesh); 
        }
        createGalaxyWithRealStars();

        // --- MATH UTILS ---
        function noise3D(x, y, z, scale = 1.0, seed = 0) {
            return Math.sin(x*scale + seed) * Math.cos(y*scale + seed) * Math.sin(z*scale + seed);
        }

        function getPlanetColor(name, x, y, z, r) {
            const c = new THREE.Color();
            const normY = y / r;
            const absY = Math.abs(normY);
            if (name === "Earth") {
                const continent = noise3D(x, y, z, 0.45) + noise3D(x, y, z, 1.2)*0.5;
                if (absY > 0.88) c.setHex(0xFFFFFF); 
                else if (continent > 0.35) { if(continent > 0.65) c.setHex(0x8B4513); else if(continent < 0.42) c.setHex(0xD2B48C); else c.setHex(0x2E8B57); } 
                else { c.setHex(0x001144); if(continent > 0.2) c.setHex(0x004499); }
            } else if (name === "Jupiter") {
                const bands = Math.sin(y * 1.8) + noise3D(x, z, y, 0.4)*0.3; const isSpot = (x > r*0.4 && x < r*0.8 && y > -r*0.35 && y < -r*0.1 && z > 0);
                if(isSpot) c.setHex(0x992200); else { if (bands > 0.6) c.setHex(0xF0E2C8); else if (bands > 0.2) c.setHex(0xCFA374); else if (bands > -0.3) c.setHex(0x7A5A40); else c.setHex(0xE0C090); }
            } else if (name === "Mars") { const terrain = noise3D(x, y, z, 0.7); c.setHex(0xCC4422); if(terrain > 0.5) c.setHex(0x8B3311); if(absY > 0.93) c.setHex(0xFFFFFF); }
            else if (name === "Venus") { const clouds = noise3D(x, y, z, 0.5) + Math.sin(y*2); c.setHex(0xFFAA33); if(clouds > 0.5) c.setHex(0xFFCC66); }
            else if (name === "Mercury") { c.setHex(0xAAAAAA); if(noise3D(x,y,z,1.5)>0.5) c.setHex(0x777777); }
            else if (name === "Saturn") { c.setHex(0xEAD6B8); if(Math.sin(y*3) > 0.5) c.setHex(0xD6BC92); }
            else if (name === "Uranus") c.setHex(0x73D7EE);
            else if (name === "Neptune") { c.setHex(0x3355FF); if(noise3D(x,y,z,0.9)>0.7) c.setHex(0x112266); }
            c.offsetHSL(0, 0, (Math.random()-0.5)*0.08); return c;
        }

        function getFibonacciSpherePoints(samples, radius) {
            const points = []; const phi = Math.PI * (3 - Math.sqrt(5)); 
            for (let i = 0; i < samples; i++) { const y = 1 - (i / (samples - 1)) * 2; const r = Math.sqrt(1 - y * y); const theta = phi * i; points.push(Math.cos(theta)*r*radius, y*radius, Math.sin(theta)*r*radius); }
            return points;
        }

        // --- SOLAR SYSTEM BUILDERS ---
        let sunParticles;
        function createSun() {
            const r = 18; const pts = getFibonacciSpherePoints(15000, r);
            for(let i=0; i<5000; i++){ const t=Math.random()*Math.PI*2, p=Math.acos(2*Math.random()-1), d=r+Math.random()*12; pts.push(d*Math.sin(p)*Math.cos(t), d*Math.sin(p)*Math.sin(t), d*Math.cos(p)); }
            const geo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
            const cols = []; const c1 = new THREE.Color(0xFFCC00); const c2 = new THREE.Color(0xFF2200);
            for(let i=0; i<pts.length; i+=3) { const d = Math.sqrt(pts[i]**2+pts[i+1]**2+pts[i+2]**2); const t = (d-r)/12; const c = c1.clone().lerp(c2, t); 
                c.multiplyScalar(2.0); 
                cols.push(c.r, c.g, c.b); 
            }
            geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
            const mesh = new THREE.Points(geo, particleMat.clone()); mesh.material.size = 3.5; sunParticles = mesh;
            const light = new THREE.PointLight(0xffaa00, 2, 800); mesh.add(light);
            const div = document.createElement('div'); div.className='label'; div.textContent='SUN';
            div.onclick = () => focusOn(mesh, 0, 'SUN', div);
            const label = new CSS2DObject(div); label.position.set(0, r+5, 0); mesh.add(label); return mesh;
        }
        scene.add(createSun());

        const planetSystems = [];
        let focusTarget = null;

        PLANETS.forEach(data => {
            const group = new THREE.Group();
            const pts = getFibonacciSpherePoints(data.particles, data.r); const cols = [];
            for(let i=0; i<pts.length; i+=3){ const x=pts[i], y=pts[i+1], z=pts[i+2]; const c = getPlanetColor(data.name, x, y, z, data.r); cols.push(c.r, c.g, c.b); }
            const geo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(pts, 3)).setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
            const mesh = new THREE.Points(geo, particleMat.clone()); group.add(mesh);

            if(data.hasClouds || data.name==="Venus") {
                const cPts = getFibonacciSpherePoints(3500, data.r*1.06); const cGeo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(cPts, 3));
                const cMat = particleMat.clone(); cMat.color.setHex(0xFFFFFF); cMat.opacity = data.name==="Venus"?0.2:0.4; cMat.size=CONFIG.particleSize*0.9;
                if(data.name==="Earth") { const filtered=[]; for(let i=0; i<cPts.length; i+=3){ if(noise3D(cPts[i], cPts[i+1], cPts[i+2], 0.35, 1)>0.2) filtered.push(cPts[i], cPts[i+1], cPts[i+2]); } cGeo.setAttribute('position', new THREE.Float32BufferAttribute(filtered, 3)); }
                const clouds = new THREE.Points(cGeo, cMat); clouds.userData.isCloud=true; group.add(clouds);
            }
            if(data.hasRings) {
                const rPts=[], rCols=[]; const inner=data.r*1.3, outer=data.r*2.5;
                for(let k=0; k<20000; k++){ const ang=Math.random()*Math.PI*2; const rad=Math.sqrt(Math.random()*(outer**2-inner**2)+inner**2); if(rad>data.r*1.9 && rad<data.r*2.05) continue; rPts.push(Math.cos(ang)*rad, (Math.random()-0.5)*0.15, Math.sin(ang)*rad); const rc=new THREE.Color(0xD6BC92); if(rad>data.r*2.1) rc.setHex(0xA89F91); rc.offsetHSL(0,0,(Math.random()-0.5)*0.1); rCols.push(rc.r,rc.g,rc.b); }
                const rGeo = new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(rPts,3)).setAttribute('color', new THREE.Float32BufferAttribute(rCols,3));
                const rMesh = new THREE.Points(rGeo, particleMat.clone()); rMesh.rotation.x=0.45; rMesh.material.opacity=0.6; rMesh.material.size=1.4; group.add(rMesh);
            }
            const div = document.createElement('div'); div.className='label'; div.textContent=data.name; div.onclick = () => focusOn(group, data.r, data.name, div);
            const label = new CSS2DObject(div); label.position.set(0, data.r+3, 0); group.add(label);
            const path = new THREE.Line(new THREE.BufferGeometry().setFromPoints(new THREE.EllipseCurve(0,0,data.dist,data.dist,0,2*Math.PI).getPoints(120)), new THREE.LineBasicMaterial({color:0xffffff, opacity:0.1, transparent:true})); path.rotation.x = Math.PI/2; scene.add(path);
            scene.add(group); planetSystems.push({ mesh: group, data: data });
        });

        // --- STARS (Simplified for this step) ---
        let starMesh;
        function createStars() {
            const pts=[]; for(let i=0; i<8000; i++) pts.push((Math.random()-0.5)*4000,(Math.random()-0.5)*4000,(Math.random()-0.5)*4000);
            const geo=new THREE.BufferGeometry().setAttribute('position', new THREE.Float32BufferAttribute(pts,3));
            const mat=particleMat.clone(); mat.size=1.8; mat.opacity=0.6; mat.color.setHex(0xAADDFF);
            starMesh=new THREE.Points(geo, mat); scene.add(starMesh);
        }
        createStars();

        function focusOn(target, radius, name, labelDiv) {
            document.querySelectorAll('.label').forEach(e => e.classList.remove('active')); if(labelDiv) labelDiv.classList.add('active'); document.getElementById('status').innerText = "TRACKING: " + name;
            controls.autoRotate = false; const dist = radius > 0 ? radius * 4.0 + 10 : 100; focusTarget = { obj: target, dist: dist };
        }

        window.resetCamera = function() {
            focusTarget = null; document.getElementById('status').innerText = "System Overview"; document.querySelectorAll('.label').forEach(e => e.classList.remove('active'));
            const s=camera.position.clone(); const e=new THREE.Vector3(0,180,400); let a=0; function b(){ a+=0.02; if(a<=1){ camera.position.lerpVectors(s,e,a); controls.target.lerp(new THREE.Vector3(0,0,0),0.05); requestAnimationFrame(b); } else controls.autoRotate=true; } b();
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            if(sunParticles) sunParticles.rotation.y = time * 0.05;

            planetSystems.forEach(sys => {
                const a = time * sys.data.speed * CONFIG.orbitSpeed; sys.mesh.position.x = Math.cos(a) * sys.data.dist; sys.mesh.position.z = Math.sin(a) * sys.data.dist; sys.mesh.rotation.y = time * 0.1;
                sys.mesh.children.forEach(c => { if(c.userData.isCloud) c.rotation.y = -time * 0.04; });
                if(sys.data.name === 'Jupiter') sys.mesh.children[0].rotation.y = time * 0.2;
            });

            if(focusTarget) {
                const tPos = new THREE.Vector3(); focusTarget.obj.getWorldPosition(tPos); controls.target.lerp(tPos, 0.08);
                const offset = camera.position.clone().sub(tPos); const current = offset.length(); const newD = THREE.MathUtils.lerp(current, focusTarget.dist, 0.08);
                offset.setLength(newD); camera.position.copy(tPos.clone().add(offset));
            }

            const dist = camera.position.length();
            if(galaxyMesh) {
                const op = THREE.MathUtils.clamp((dist - 2000) / 10000, 0, 1);
                galaxyMesh.material.opacity = op;
                if(nebulaeMesh) nebulaeMesh.material.opacity = op * 0.6;
                galaxyMesh.rotation.y = time * 0.005; 
            }
            
            const labels = document.querySelectorAll('.label');
            if(dist > 3000) { labels.forEach(l => l.classList.add('hidden')); document.getElementById('status').innerText="MILKY WAY GALAXY"; }
            else { labels.forEach(l => l.classList.remove('hidden')); }
            
            if(starMesh) starMesh.material.opacity = 0.5 + Math.sin(time*3)*0.2;

            controls.update();
            labelRenderer.render(scene, camera);
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight); 
            composer.setSize(window.innerWidth, window.innerHeight);
            labelRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>